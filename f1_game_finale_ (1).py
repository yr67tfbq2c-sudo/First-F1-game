# -*- coding: utf-8 -*-
"""f1 game finale.

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1y5z05HZP58ymeom0b4k9gdqLph1mqtSX
"""

# This game is inspired by the beauty of Formula 1
# part1 the player and their stats

import random
import time


print("welcome to formula 1, Driver!!")

# This is where the player is created and where they inputs their names and recieves randomly generated stats
name = input(" What is your name: ")

# Easter egg for legendary drivers
special_car = None
if name == "Sir Lewis Hamilton":
    special_car = "Mercedes W11"
    print(f"THE GOAT HAS ARRIVED! You've unlocked the legendary {special_car}!")
    time.sleep(2)
elif name == "Ayrton Senna":
    special_car = "McLaren MP4/4"
    print(f"A LEGEND HAS RETURNED! You've unlocked the iconic {special_car}!")
    time.sleep(2)
elif name == "Michael Schumacher":
    special_car = "Ferrari F2004"
    print(f"A LEGEND HAS RETURNED! You've unlocked the dominant {special_car}!")
    time.sleep(2)

#get the user stats
def generate_character_stats(stat_ranges):
    return [random.randint(stat_range[0], stat_range[1] ) for stat_range in stat_ranges]

#this is where the stats range is defined for different attributes
# The stats will include luck, intelligence, handling skill, G-force resistance

def main():
    time.sleep(1)
    stat_ranges = [
        (1, 50), # this is for Luck
        (1, 50), # this is for intelligence
        (1, 50), # this is for Handling skill
        (1, 50) # this is for G-force resistance
    ]
    stat_names = [ "Luck", "intelligence", "handling skill", "G-force resistance"] #the stats name

# Now, let's generate the random stat
    stats = generate_character_stats(stat_ranges)

#print the result and pray it works
    print(f"\nCharacter stats for {name}:")
    for stat_name, stat in zip(stat_names, stats): # The zip() function in Python is like a zipper on a jacket that brings two sides together.
      print(f"{stat_name}: {stat}")

if __name__ == "__main__":
    main()

# Now try to run it and PRAY TO GOD it works
# Let's GOOOOOOOOOOOO it worked!!!

                                                  #F-strings provide a concise way to embed expressions inside string literals for formatting.
#part2
# Recommend the driver to go to the garage and pick which team they will drive for

import random
import time

# Track information database
tracks = {
    "Bahrain": {
        "name": "Bahrain International Circuit",
        "location": "Sakhir, Bahrain",
        "turns": 15,
        "straights": 3,
        "description": "Features a main straight approximately 1.09 kilometers long, leading into Turn 1, which is a prime overtaking spot."
    },
    "Jeddah": {
        "name": "Jeddah Corniche Circuit",
        "location": "Jeddah, Saudi Arabia",
        "turns": 17,
        "straights": 4,
        "description": "Known for its high-speed nature, the circuit includes several fast sections, with the longest straight extending over 1.2 kilometers, facilitating significant overtaking opportunities."
    },
    "Melbourne": {
        "name": "Melbourne Grand Prix Circuit (Albert Park Circuit)",
        "location": "Melbourne, Australia",
        "turns": 14,
        "straights": 3,
        "description": "The circuit underwent modifications to remove a chicane, resulting in a high-speed straight between Turns 6 and 11, enhancing overtaking prospects."
    },
    "Suzuka": {
        "name": "Suzuka International Racing Course",
        "location": "Suzuka, Japan",
        "turns": 18,
        "straights": 2,
        "description": "Features a main straight approximately 1.2 kilometers long, leading into the First Corner, a challenging right-hander that sets the tone for the lap."
    },
    "Monaco": {
        "name": "Circuit de Monaco",
        "location": "Monte Carlo, Monaco",
        "turns": 10,
        "straights": 1,
        "description": "Due to its tight and twisty nature, Monaco lacks significant straights; the longest is the stretch from the exit of the Tunnel to the Nouvelle Chicane."
    },
    "Abu Dhabi": {
        "name": "Yas Marina Circuit",
        "location": "Abu Dhabi, UAE",
        "turns": 11,
        "straights": 2,
        "description": "The circuit includes two long straights; the longest is between Turns 5 and 6, approximately 1.2 kilometers, often utilized as a DRS zone to encourage overtaking."
    },
    "Las Vegas": {
        "name": "Las Vegas Street Circuit",
        "location": "Las Vegas, USA",
        "turns": 14,
        "straights": 3,
        "description": "Incorporates a significant straight along the Las Vegas Strip, approximately 1.9 kilometers long, making it one of the longest straights in the F1 calendar and a key overtaking area."
    }
}

def get_player_roll(high_roll_count, consecutive_wins):
    """Get a dice roll from the player (1-10) with warnings for repeated high rolls or consecutive wins"""
    while True:
        try:
            # Warning for consecutive wins (pushing too hard)
            if consecutive_wins >= 4:
                print("\nWARNING: You've won 4 times in a row! You're pushing the car to its limits.")
                print("Be careful or you might lose control!")

            roll = int(input("Choose your dice roll (1-10): "))
            if 1 <= roll <= 10:
                # If roll is high (8-10) and high_roll_count is already elevated, give warnings
                if roll >= 8:
                    if high_roll_count == 2:
                        print("WARNING: You're pushing the car too hard! Ease off the gas or risk losing control!")
                    elif high_roll_count >= 3:
                        print("DANGER: The car is on the edge of control!")
                return roll
            else:
                print("Please enter a number between 1 and 10.")
        except ValueError:
            print("Invalid input. Please enter a number between 1 and 10.")

def get_rival_roll(consecutive_player_wins):
    """Generate a challenging rival roll

    Returns one of the top 3 numbers (8-10) normally,
    but can return 11-16 if player has won 3 consecutive times (DRS activation)
    """
    if consecutive_player_wins >= 3:
        # 80% chance of DRS activation (super high roll) when player has won 3+ consecutive times
        if random.random() < 0.8:
            # DRS activated - stronger response with higher consecutive wins
            rival_roll = random.randint(12, 16 + min(consecutive_player_wins - 3, 4))
            return rival_roll, True  # Return the roll and flag that it was a special roll (DRS)

    # Otherwise, pick from the top 3 numbers (8-10)
    rival_roll = random.randint(7, 10)
    return rival_roll, False  # Normal roll

def race_simulation(player_name, player_car, player_stats, rival_name, rival_car):
    """Simulate a race between player and rival using dice rolls"""
    # Choose a random track
    track_key = random.choice(list(tracks.keys()))
    track = tracks[track_key]

    print(f"\nWelcome to the {track['name']} in {track['location']}!")
    print(f"This track features {track['turns']} turns and {track['straights']} notable straights.")
    print(f"Track info: {track['description']}")
    time.sleep(2)

    player_position = 0
    rival_position = 0
    consecutive_player_wins = 0  # Track consecutive player wins for difficulty adjustment
    high_roll_count = 0  # Track how many times the player selects high rolls consecutively
    handling_bonus_counter = 0  # Count turns to phase out handling bonus
    crashed = False  # Flag to track if player has crashed
    pushing_hard_turns = 0  # Track how many turns the player has been pushing too hard

    print("\nRace starting in...")
    for i in range(3, 0, -1):
        print(f"{i}...")
        time.sleep(1)
    print("GO!\n")
    time.sleep(1)

    total_turns = track['turns'] + track['straights']
    current_turn = 0

    # Process turns
    for turn_num in range(1, track['turns'] + 1):
        current_turn += 1
        print(f"\n--- Turn {turn_num} ---")
        time.sleep(0.5)
        print("Your car approaches the turn...")

        # Skip player input if they've crashed
        if crashed:
            print(f"{player_name} is out of the race after crashing!")
            rival_position += 1
            print(f"Current standings: {player_name} {player_position} - {rival_position} {rival_name}")
            continue

        # Player chooses their roll
        player_roll = get_player_roll(high_roll_count, consecutive_player_wins)

        # Track high rolls
        if player_roll >= 8:
            high_roll_count += 1
            pushing_hard_turns += 1

            # Check if player has been pushing too hard for 7+ turns
            if pushing_hard_turns >= 7:
                print(f"\nDISASTER! After pushing the {player_car} too hard for {pushing_hard_turns} turns, something has failed!")
                time.sleep(1)
                print("You hear a loud pop from the engine and smoke begins pouring from the back!")
                time.sleep(1)
                print("MECHANICAL FAILURE - DNF! Your race is OVER.")
                crashed = True
                break
        else:
            high_roll_count = max(0, high_roll_count - 1)  # Gradually decrease the counter if lower rolls are chosen
            pushing_hard_turns = max(0, pushing_hard_turns - 1)  # Gradually decrease the pushing hard counter

        # Check for crash based on high roll count
        if high_roll_count >= 4 and random.random() < 0.7:  # 70% chance of crash after 4+ high rolls
            print(f"\nDISASTER! {player_name} has pushed the {player_car} too hard!")
            time.sleep(1)
            print("The car loses traction, spins violently, and CRASHES into the barriers!")
            time.sleep(1)
            print("Race engineers and medical team rush to the scene...")
            time.sleep(1)
            print("Fortunately, you're unharmed but your race is OVER.")
            crashed = True
            break

        # Calculate handling bonus (diminishes over time)
        handling_bonus_counter += 1
        max_bonus_turns = random.randint(5, 7)  # Handling bonus disappears after 5-7 turns

        if handling_bonus_counter <= max_bonus_turns:
            handling_bonus = min(2, player_stats["handling"] // 50)
            bonus_text = f" (+{handling_bonus} handling bonus)"
        else:
            handling_bonus = 0
            bonus_text = ""

            # First turn after bonus disappears, show a message
            if handling_bonus_counter == max_bonus_turns + 1:
                print("Your tires are wearing down! Handling bonus is gone.")

        player_total = min(12, player_roll + handling_bonus)

        # Rival roll - challenging!
        rival_roll, special_roll = get_rival_roll(consecutive_player_wins)

        print(f"{player_name} rolls a {player_roll}{bonus_text if handling_bonus > 0 else ''} = {player_total}")

        if special_roll:
            print(f"{rival_name} is pushing hard and rolls a {rival_roll}! They're responding to your streak!")
        else:
            print(f"{rival_name} rolls a {rival_roll}")

        if player_total > rival_roll:
            player_position += 1
            consecutive_player_wins += 1
            print(f"{player_name} takes the corner better and gains ground!")
        elif player_total < rival_roll:
            rival_position += 1
            consecutive_player_wins = 0  # Reset the streak
            print(f"{rival_name} handles the corner better and pulls ahead!")
        else:
            print("Both drivers take the corner equally well!")
            consecutive_player_wins = 0  # Reset on ties too

        time.sleep(1)
        print(f"Current standings: {player_name} {player_position} - {rival_position} {rival_name}")
        if consecutive_player_wins >= 3:
            print(f"You're on fire with {consecutive_player_wins} consecutive wins! The rival is getting desperate...")

    # Race through straights (skip if crashed)
    if not crashed:
        for straight_num in range(1, track['straights'] + 1):
            current_turn += 1
            print(f"\n--- Straight {straight_num} ---")
            time.sleep(0.5)
            print("You hit the throttle on the straight...")

            # Player chooses their roll
            player_roll = get_player_roll(high_roll_count, consecutive_player_wins)

            # Track high rolls
            if player_roll >= 8:
                high_roll_count += 1
                pushing_hard_turns += 1

                # Check if player has been pushing too hard for 7+ turns
                if pushing_hard_turns >= 7:
                    print(f"\nDISASTER! After pushing the {player_car} to the limits for {pushing_hard_turns} turns, the engine gives out!")
                    time.sleep(1)
                    print("Blue smoke billows from the exhaust as you hear a catastrophic internal failure!")
                    time.sleep(1)
                    print("ENGINE BLOWN - DNF! Your race is OVER.")
                    crashed = True
                    break
            else:
                high_roll_count = max(0, high_roll_count - 1)  # Gradually decrease if lower rolls are chosen
                pushing_hard_turns = max(0, pushing_hard_turns - 1)  # Gradually decrease the pushing hard counter

            # Check for crash based on high roll count
            if high_roll_count >= 4 and random.random() < 0.7:  # 70% chance of crash after 4+ high rolls
                print(f"\nDISASTER! {player_name} has pushed the {player_car} too hard!")
                time.sleep(1)
                print("The car loses control at high speed and SLAMS into the barriers!")
                time.sleep(1)
                print("Yellow flags are waving! Medical car deployed!")
                time.sleep(1)
                print("Fortunately, you're unharmed but your race is OVER.")
                crashed = True
                break

            # Calculate speed bonus (diminishes over time)
            speed_bonus_counter = handling_bonus_counter
            max_bonus_turns = random.randint(5, 7)

            if speed_bonus_counter <= max_bonus_turns:
                speed_bonus = min(2, player_stats["speed"] // 50)
                bonus_text = f" (+{speed_bonus} speed bonus)"
            else:
                speed_bonus = 0
                bonus_text = ""

                # First turn after bonus disappears, show a message
                if speed_bonus_counter == max_bonus_turns + 1:
                    print("Your engine temperature is rising! Speed bonus is gone.")

            player_total = min(12, player_roll + speed_bonus)

            # Rival roll - challenging!
            rival_roll, special_roll = get_rival_roll(consecutive_player_wins)

            print(f"{player_name} rolls a {player_roll}{bonus_text if speed_bonus > 0 else ''} = {player_total}")

            if special_roll:
                if consecutive_player_wins >= 3:
                    print(f"{rival_name} activates DRS and rolls a {rival_roll}! They're desperate to catch up!")
                else:
                    print(f"{rival_name} pushes hard and rolls a {rival_roll}! They're determined to catch up!")
            else:
                print(f"{rival_name} rolls a {rival_roll}")

            if player_total > rival_roll:
                player_position += 1
                consecutive_player_wins += 1
                print(f"{player_name} accelerates better and gains ground!")
            elif player_total < rival_roll:
                rival_position += 1
                consecutive_player_wins = 0  # Reset the streak
                print(f"{rival_name} has better straight-line speed and pulls ahead!")
            else:
                print("Both drivers maintain their positions on the straight!")
                consecutive_player_wins = 0  # Reset on ties too

            time.sleep(1)
            print(f"Current standings: {player_name} {player_position} - {rival_position} {rival_name}")
            if consecutive_player_wins >= 5:
                print(f"You're on fire with {consecutive_player_wins} consecutive wins! The rival is getting desperate...")

    # Race results
    print("\n--- RACE FINISHED ---")
    print(f"{player_name}: {player_position} points" + (" (DNF - Crashed)" if crashed else ""))
    print(f"{rival_name}: {rival_position} points")

    if crashed:
        print(f"\nYou've crashed out of the race. {rival_name} takes the win!")
        print("Better luck next time, and remember to manage your car's limits!")
    elif player_position > rival_position:
        print(f"\nCongratulations {player_name}! You've beaten {rival_name} and proven your skills on the track!")
    elif player_position < rival_position:
        print(f"\nYou lost the Wdc, {rival_name} has beaten you this time. Better luck next season!")
    else:
        print(f"\nIncredible! It's a tie between you and {rival_name}! What a thrilling race!")

def visit_garage():
    """
    Allow the player to choose a team from the garage.
    :return: A dictionary containing the chosen team's name, car, and stats.
    """
    print(" Welcome to the garage driver ")
    print("choose your team driver:")
# List the teams' names
    teams = {
        "1": {"name": "Alpine", "car": "Alpine A525"},
        "2": {"name": "Aston Martin", "car": "Aston Martin AMR25"},
        "3": {"name": "Ferrari", "car": "Ferrari SF-25"},
        "4": {"name": "Haas", "car": "Haas VF-25"},
        "5": {"name": "McLaren", "car": "McLaren MCL39"},
        "6": {"name": "Mercedes", "car": "Mercedes W16"},
        "7": {"name": "Red Bull", "car": "Red Bull RB21"},
        "8": {"name": "Racing Bulls", "car": "Racing Bulls"},
        "9": {"name": "Sauber", "car": "Sauber C45"},
       "10": {"name": "Williams", "car": "Williams FW47"}
    }

    # If player has the special car from Easter egg, replace the corresponding team's car
    if special_car:
        if special_car == "Mercedes W11":
            teams["6"]["car"] = special_car
        elif special_car == "McLaren MP4/4":
            teams["5"]["car"] = special_car
        elif special_car == "Ferrari F2004":
            teams["3"]["car"] = special_car

# This is how the teams will show up, you're pretty much displaying the teams
    for key, team in teams.items():
         print(f"{key}. {team['name']} - {team['car']}")
         time.sleep(0.5)

#delay before the user choice
    time.sleep(1.5)

    # This is where the player makes their choice
    while True:
        choice = input(f"\nEnter the number of the team you want to drive for (1-10): ")

    # validate input of the user

        if choice in teams:
             selected_team = teams [choice]
             print(f"\nYou joined {selected_team['name']} and will be driving the {selected_team['car']} Good luck driver!")
             break # This is in case the choice was correct
        else:
            print("invalid choice drive. Please pick another number between 1 and 10 ")

        # Generate random team stats because NOT ALL TEAMS ARE EQUAL LOSERS!!!! FERRARI IS ON TOP!!!!!
    team_stats = {
        "speed": random.randint (100,350),
        "handling": random.randint (70,100),
        "Acceleration": random.randint (100,200),
        "Reliability": random.randint (40,100),
        "DownForce": random.randint (50,100)
    }

        # Boost certain team stats (it must be fair) and this is just for Fun!! not because I want certain teams to be better or something.
    if selected_team["name"] == "Ferrari":
        team_stats["handling"] = min(int(team_stats["handling"] * 1.3 ), 100)
        team_stats["Acceleration"] = min(int(team_stats["Acceleration"] * 1.3 ), 200)
        team_stats["Reliability"] = min(int(team_stats["Reliability"] * 1.3 ), 100)
    elif selected_team["name"] == "Red Bull":
        team_stats["speed"] = min(int(team_stats["speed"] * 1.1 ), 350)
        team_stats["DownForce"] = min(int(team_stats["DownForce"] * 1.3 ), 100)
        team_stats["handling"] = min(int(team_stats["handling"] * 1.2 ), 100)
    elif selected_team["name"] == "Mercedes":
        team_stats["speed"] = min(int(team_stats["speed"] * 1.2 ), 350)
        team_stats["Acceleration"] = min(int(team_stats["Acceleration"] * 1.3 ), 200)
        team_stats["handling"] = min(int(team_stats["handling"] * 1.3 ), 100)
    elif selected_team["name"] == "McLaren":
        team_stats["speed"] = min(int(team_stats["speed"] * 1.4 ), 350)
        team_stats["Acceleration"] = min(int(team_stats["Acceleration"] * 1.3 ), 200)
        team_stats["Reliability"] = min(int(team_stats["Reliability"] * 1.3 ), 100)

    # Apply legendary car boost for the special cars
    if special_car:
        if selected_team["car"] == "Mercedes W11" or selected_team["car"] == "McLaren MP4/4" or selected_team["car"] == "Ferrari F2004":
            for stat in team_stats:
                team_stats[stat] = min(int(team_stats[stat] * 1.5), 350)

            if selected_team["car"] == "Mercedes W11":
                print("\nThe legendary Mercedes W11 dominates with superior performance!")
            elif selected_team["car"] == "McLaren MP4/4":
                print("\nThe iconic McLaren MP4/4 showcases its legendary capabilities!")
            elif selected_team["car"] == "Ferrari F2004":
                print("\nThe dominant Ferrari F2004 demonstrates its unmatched power!")

# set the MAX for a team at 350 because the Math must be Mathing ( too lazy to add extra )
    for stat in team_stats:
        team_stats[stat] = min(team_stats[stat], 350)
# show the stats of the car
    print("\nCar statistics:")
    time.sleep(1)
    for stat, value in team_stats.items():
        print(f"{stat}: {value}")
        time.sleep(.75)
    time.sleep(2)

# part 3: Introduce Rival driver and race them
    print("\nAs you are parked in your team's garage a rival appears...")
    time.sleep(2)

    # Rival asks who the player is and calls them "farmer"
    print("'Who do you think you are, farmer? You don't belong on this track!' the rival looks down on you.")
    time.sleep(1.5)
    track_name = input("What track are you famous for mastering? ")
    print(f"'Ha! {track_name}? That's nothing special. Let's see if you can back up your talk with speed!'")
    time.sleep(1.75)

    print(" The rival driver challenges you to a race ")
    time.sleep(1.75)

    Rivals = [
        {"name": "Michael Schumacher", "car": "Ferrari F2004" },
        {"name": "Lewis Hamilton", "car": "Mercedes W11" },
        {"name": "Max Verstappen", "car": "Red Bull RB21" },
        {"name": "Ayrton Senna", "car": "McLaren MP4/4" }
    ]

    Rival = random.choice(Rivals)
    print(f"Your rival is {Rival['name']} driving the {Rival['car']}!")

    # Ask if player wants to race
    race_choice = input("\nDo you accept the challenge to race? (yes/no): ").lower()

    if race_choice == "yes":
        print("\nPrepping cars for race...")
        time.sleep(2)
        # Run the race simulation
        race_simulation(name, selected_team["car"], team_stats, Rival["name"], Rival["car"])
    else:
        print("\nWOW! You're backing down? What a loser! You clearly don't belong here.")
        print("GAME OVER - You've lost all respect in the paddock.")
        exit()

visit_garage()
# prompt user to race and accept the challenge